{"ast":null,"code":"/**\r\n * NLP Utilities for the KSP Yarns Chatbot\r\n * Lightweight natural language processing functions for improved text matching\r\n */\n\n// Stopwords - common words that don't add significant meaning\nconst stopwords = ['a', 'an', 'the', 'and', 'or', 'but', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'in', 'on', 'at', 'to', 'for', 'with', 'by', 'about', 'against', 'between', 'into', 'through', 'during', 'before', 'after', 'above', 'below', 'from', 'up', 'down', 'of', 'off', 'over', 'under', 'again', 'further', 'then', 'once', 'here', 'there', 'when', 'where', 'why', 'how', 'all', 'any', 'both', 'each', 'few', 'more', 'most', 'other', 'some', 'such', 'no', 'nor', 'not', 'only', 'own', 'same', 'so', 'than', 'too', 'very', 'can', 'will', 'just', 'should', 'now', 'i', 'me', 'my', 'myself', 'we', 'our', 'ours', 'ourselves', 'you', 'your', 'yours', 'yourself', 'yourselves', 'he', 'him', 'his', 'himself', 'she', 'her', 'hers', 'herself', 'it', 'its', 'itself', 'they', 'them', 'their', 'theirs', 'themselves', 'what', 'which', 'who', 'whom', 'this', 'that', 'these', 'those', 'do', 'does', 'did', 'doing', 'have', 'has', 'had', 'having', 'would', 'could', 'should', 'ought', 'i\\'m', 'you\\'re', 'he\\'s', 'she\\'s', 'it\\'s', 'we\\'re', 'they\\'re', 'i\\'ve', 'you\\'ve', 'we\\'ve', 'they\\'ve', 'i\\'d', 'you\\'d', 'he\\'d', 'she\\'d', 'we\\'d', 'they\\'d', 'i\\'ll', 'you\\'ll', 'he\\'ll', 'she\\'ll', 'we\\'ll', 'they\\'ll', 'isn\\'t', 'aren\\'t', 'wasn\\'t', 'weren\\'t', 'hasn\\'t', 'haven\\'t', 'hadn\\'t', 'doesn\\'t', 'don\\'t', 'didn\\'t', 'won\\'t', 'wouldn\\'t', 'shan\\'t', 'shouldn\\'t', 'can\\'t', 'cannot', 'couldn\\'t', 'mustn\\'t', 'let\\'s', 'that\\'s', 'who\\'s', 'what\\'s', 'here\\'s', 'there\\'s', 'when\\'s', 'where\\'s', 'why\\'s', 'how\\'s'];\n\n// Simple stemmer - converts words to their root form\nconst stemWord = word => {\n  word = word.toLowerCase();\n\n  // Handle common suffixes\n  if (word.endsWith('ing')) {\n    // dancing -> danc\n    return word.slice(0, -3);\n  } else if (word.endsWith('ly')) {\n    // quickly -> quick\n    return word.slice(0, -2);\n  } else if (word.endsWith('ies')) {\n    // companies -> compani\n    return word.slice(0, -3) + 'y';\n  } else if (word.endsWith('es')) {\n    // boxes -> box\n    return word.slice(0, -2);\n  } else if (word.endsWith('s') && !word.endsWith('ss')) {\n    // cats -> cat, but not pass -> pas\n    return word.slice(0, -1);\n  } else if (word.endsWith('ed') && word.length > 4) {\n    // jumped -> jump\n    return word.slice(0, -2);\n  }\n  return word;\n};\n\n// Tokenize text into words, remove stopwords, and apply stemming\nexport const preprocessText = text => {\n  if (!text) return [];\n\n  // Convert to lowercase and remove special characters\n  const cleanText = text.toLowerCase().replace(/[^\\w\\s]/g, ' ');\n\n  // Tokenize into words\n  const tokens = cleanText.split(/\\s+/).filter(token => token.length > 1);\n\n  // Remove stopwords and apply stemming\n  return tokens.filter(token => !stopwords.includes(token)).map(token => stemWord(token));\n};\n\n// Calculate TF (Term Frequency) for a term in a document\nconst calculateTF = (term, document) => {\n  const termFrequency = document.filter(word => word === term).length;\n  return termFrequency / document.length;\n};\n\n// Calculate cosine similarity between two documents (vectors)\nconst cosineSimilarity = (docA, docB) => {\n  const termsA = [...new Set(docA)];\n  const termsB = [...new Set(docB)];\n  const allTerms = [...new Set([...termsA, ...termsB])];\n\n  // Create term frequency vectors\n  const vectorA = allTerms.map(term => calculateTF(term, docA));\n  const vectorB = allTerms.map(term => calculateTF(term, docB));\n\n  // Calculate dot product\n  let dotProduct = 0;\n  for (let i = 0; i < allTerms.length; i++) {\n    dotProduct += vectorA[i] * vectorB[i];\n  }\n\n  // Calculate magnitudes\n  const magnitudeA = Math.sqrt(vectorA.reduce((sum, val) => sum + val * val, 0));\n  const magnitudeB = Math.sqrt(vectorB.reduce((sum, val) => sum + val * val, 0));\n\n  // Handle edge case\n  if (magnitudeA === 0 || magnitudeB === 0) return 0;\n\n  // Return cosine similarity\n  return dotProduct / (magnitudeA * magnitudeB);\n};\n\n// Calculate semantic similarity between two texts\nexport const calculateSimilarity = (textA, textB) => {\n  // Preprocess both texts\n  const tokensA = preprocessText(textA);\n  const tokensB = preprocessText(textB);\n  if (tokensA.length === 0 || tokensB.length === 0) return 0;\n\n  // Calculate cosine similarity\n  return cosineSimilarity(tokensA, tokensB);\n};\n\n// Find the best match in a set of documents for a query\nexport const findBestMatch = (query, documents, threshold = 0.2) => {\n  if (!query || !documents || documents.length === 0) return null;\n  const processedQuery = preprocessText(query);\n\n  // Calculate similarity scores for each document\n  const scores = documents.map(doc => {\n    var _doc$keywords;\n    return {\n      document: doc,\n      similarity: calculateSimilarity(processedQuery, doc.text || ((_doc$keywords = doc.keywords) === null || _doc$keywords === void 0 ? void 0 : _doc$keywords.join(' ')) || '')\n    };\n  });\n\n  // Sort by similarity score (descending)\n  scores.sort((a, b) => b.similarity - a.similarity);\n\n  // Return the best match if it meets the threshold\n  return scores[0].similarity >= threshold ? scores[0].document : null;\n};\n\n// Extract entities from text (e.g., product names, numbers, dates)\nexport const extractEntities = text => {\n  const entities = {\n    products: [],\n    numbers: [],\n    dates: [],\n    locations: []\n  };\n  if (!text) return entities;\n\n  // Extract numbers (including those with units)\n  const numberPattern = /\\b\\d+(\\.\\d+)?\\s*(kg|g|mm|cm|m|inch|inches|yards|counts|ne)?\\b/gi;\n  const numberMatches = text.match(numberPattern) || [];\n  entities.numbers = numberMatches.map(match => match.trim());\n\n  // Extract dates\n  const datePattern = /\\b(?:\\d{1,2}[-/]\\d{1,2}[-/]\\d{2,4}|\\d{1,2}(?:st|nd|rd|th)?\\s+(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*(?:\\s+\\d{2,4})?)\\b/gi;\n  entities.dates = text.match(datePattern) || [];\n\n  // Extract common yarn types/products\n  const yarnTypes = ['cotton', 'polyester', 'blend', 'recycled', 'organic', 'vortex', 'ring spun', 'open end', 'oe yarn'];\n  yarnTypes.forEach(type => {\n    if (text.toLowerCase().includes(type)) {\n      entities.products.push(type);\n    }\n  });\n\n  // Extract locations\n  const locations = ['india', 'karur', 'tamil nadu', 'sukkaliyur'];\n  locations.forEach(location => {\n    if (text.toLowerCase().includes(location)) {\n      entities.locations.push(location);\n    }\n  });\n  return entities;\n};\n\n// Function to detect intent from user input\nexport const detectIntent = text => {\n  const lowerText = text.toLowerCase();\n\n  // Common intent patterns\n  const intentPatterns = {\n    greeting: [/^hi\\b|^hello\\b|^hey\\b|^greetings\\b|^good morning\\b|^good afternoon\\b|^good evening\\b/i],\n    farewell: [/^bye\\b|^goodbye\\b|^see you\\b|^farewell\\b|^have a good day\\b/i],\n    information: [/what|how|which|where|when|why|who|tell me about|can you explain|i need to know|i want to know/i, /about your company|about ksp yarns|company details|company information/i // Added pattern\n    ],\n    purchase: [/buy|purchase|order|shop|get|acquire|cost|price|how much|how many/i],\n    complaint: [/complaint|issue|problem|not happy|dissatisfied|poor|bad|terrible|awful|damaged|wrong/i],\n    gratitude: [/thanks|thank you|appreciate|grateful|helpful/i],\n    cancellation: [/cancel|refund|return|stop|don't want|changed my mind/i],\n    confirmation: [/confirm|verify|check|sure|right|correct|ok|yes|yep|yeah/i],\n    negation: [/no|nope|not|don't|none|never|negative/i]\n  };\n\n  // Check for each intent\n  for (const [intent, patterns] of Object.entries(intentPatterns)) {\n    for (const pattern of patterns) {\n      if (pattern.test(lowerText)) {\n        return intent;\n      }\n    }\n  }\n  return 'general';\n};\n\n// Generate contextual responses based on conversation history\nexport const generateContextualResponse = (query, matchedResponse, conversationContext) => {\n  // Removed unused intent variable\n  const entities = extractEntities(query);\n\n  // If we have a specific response, customize it based on context\n  if (matchedResponse) {\n    // Add product specificity if detected\n    if (entities.products.length > 0 && matchedResponse.includes('products')) {\n      return matchedResponse.replace('our products', `our ${entities.products.join(', ')} products`);\n    }\n\n    // Add personalization if we know the user name\n    if (conversationContext.userName && Math.random() > 0.7) {\n      if (matchedResponse.includes('.')) {\n        return matchedResponse.replace('. ', `. ${conversationContext.userName}, `);\n      }\n    }\n    return matchedResponse;\n  }\n  return null;\n};","map":{"version":3,"names":["stopwords","stemWord","word","toLowerCase","endsWith","slice","length","preprocessText","text","cleanText","replace","tokens","split","filter","token","includes","map","calculateTF","term","document","termFrequency","cosineSimilarity","docA","docB","termsA","Set","termsB","allTerms","vectorA","vectorB","dotProduct","i","magnitudeA","Math","sqrt","reduce","sum","val","magnitudeB","calculateSimilarity","textA","textB","tokensA","tokensB","findBestMatch","query","documents","threshold","processedQuery","scores","doc","_doc$keywords","similarity","keywords","join","sort","a","b","extractEntities","entities","products","numbers","dates","locations","numberPattern","numberMatches","match","trim","datePattern","yarnTypes","forEach","type","push","location","detectIntent","lowerText","intentPatterns","greeting","farewell","information","purchase","complaint","gratitude","cancellation","confirmation","negation","intent","patterns","Object","entries","pattern","test","generateContextualResponse","matchedResponse","conversationContext","userName","random"],"sources":["d:/ksp_devops/ksp_user_devops/frontend/src/utils/nlpUtils.js"],"sourcesContent":["/**\r\n * NLP Utilities for the KSP Yarns Chatbot\r\n * Lightweight natural language processing functions for improved text matching\r\n */\r\n\r\n// Stopwords - common words that don't add significant meaning\r\nconst stopwords = [\r\n  'a', 'an', 'the', 'and', 'or', 'but', 'is', 'are', 'was', 'were', 'be', 'been', 'being',\r\n  'in', 'on', 'at', 'to', 'for', 'with', 'by', 'about', 'against', 'between', 'into', 'through',\r\n  'during', 'before', 'after', 'above', 'below', 'from', 'up', 'down', 'of', 'off', 'over', 'under',\r\n  'again', 'further', 'then', 'once', 'here', 'there', 'when', 'where', 'why', 'how', 'all', 'any',\r\n  'both', 'each', 'few', 'more', 'most', 'other', 'some', 'such', 'no', 'nor', 'not', 'only', 'own',\r\n  'same', 'so', 'than', 'too', 'very', 'can', 'will', 'just', 'should', 'now', 'i', 'me', 'my', \r\n  'myself', 'we', 'our', 'ours', 'ourselves', 'you', 'your', 'yours', 'yourself', 'yourselves',\r\n  'he', 'him', 'his', 'himself', 'she', 'her', 'hers', 'herself', 'it', 'its', 'itself', 'they',\r\n  'them', 'their', 'theirs', 'themselves', 'what', 'which', 'who', 'whom', 'this', 'that', 'these',\r\n  'those', 'do', 'does', 'did', 'doing', 'have', 'has', 'had', 'having', 'would', 'could', 'should',\r\n  'ought', 'i\\'m', 'you\\'re', 'he\\'s', 'she\\'s', 'it\\'s', 'we\\'re', 'they\\'re', 'i\\'ve', 'you\\'ve',\r\n  'we\\'ve', 'they\\'ve', 'i\\'d', 'you\\'d', 'he\\'d', 'she\\'d', 'we\\'d', 'they\\'d', 'i\\'ll', 'you\\'ll',\r\n  'he\\'ll', 'she\\'ll', 'we\\'ll', 'they\\'ll', 'isn\\'t', 'aren\\'t', 'wasn\\'t', 'weren\\'t', 'hasn\\'t',\r\n  'haven\\'t', 'hadn\\'t', 'doesn\\'t', 'don\\'t', 'didn\\'t', 'won\\'t', 'wouldn\\'t', 'shan\\'t', 'shouldn\\'t',\r\n  'can\\'t', 'cannot', 'couldn\\'t', 'mustn\\'t', 'let\\'s', 'that\\'s', 'who\\'s', 'what\\'s', 'here\\'s',\r\n  'there\\'s', 'when\\'s', 'where\\'s', 'why\\'s', 'how\\'s'\r\n];\r\n\r\n// Simple stemmer - converts words to their root form\r\nconst stemWord = (word) => {\r\n  word = word.toLowerCase();\r\n  \r\n  // Handle common suffixes\r\n  if (word.endsWith('ing')) {\r\n    // dancing -> danc\r\n    return word.slice(0, -3);\r\n  } else if (word.endsWith('ly')) {\r\n    // quickly -> quick\r\n    return word.slice(0, -2);\r\n  } else if (word.endsWith('ies')) {\r\n    // companies -> compani\r\n    return word.slice(0, -3) + 'y';\r\n  } else if (word.endsWith('es')) {\r\n    // boxes -> box\r\n    return word.slice(0, -2);\r\n  } else if (word.endsWith('s') && !word.endsWith('ss')) {\r\n    // cats -> cat, but not pass -> pas\r\n    return word.slice(0, -1);\r\n  } else if (word.endsWith('ed') && word.length > 4) {\r\n    // jumped -> jump\r\n    return word.slice(0, -2);\r\n  }\r\n  \r\n  return word;\r\n};\r\n\r\n// Tokenize text into words, remove stopwords, and apply stemming\r\nexport const preprocessText = (text) => {\r\n  if (!text) return [];\r\n  \r\n  // Convert to lowercase and remove special characters\r\n  const cleanText = text.toLowerCase().replace(/[^\\w\\s]/g, ' ');\r\n  \r\n  // Tokenize into words\r\n  const tokens = cleanText.split(/\\s+/).filter(token => token.length > 1);\r\n  \r\n  // Remove stopwords and apply stemming\r\n  return tokens\r\n    .filter(token => !stopwords.includes(token))\r\n    .map(token => stemWord(token));\r\n};\r\n\r\n// Calculate TF (Term Frequency) for a term in a document\r\nconst calculateTF = (term, document) => {\r\n  const termFrequency = document.filter(word => word === term).length;\r\n  return termFrequency / document.length;\r\n};\r\n\r\n// Calculate cosine similarity between two documents (vectors)\r\nconst cosineSimilarity = (docA, docB) => {\r\n  const termsA = [...new Set(docA)];\r\n  const termsB = [...new Set(docB)];\r\n  const allTerms = [...new Set([...termsA, ...termsB])];\r\n  \r\n  // Create term frequency vectors\r\n  const vectorA = allTerms.map(term => calculateTF(term, docA));\r\n  const vectorB = allTerms.map(term => calculateTF(term, docB));\r\n  \r\n  // Calculate dot product\r\n  let dotProduct = 0;\r\n  for (let i = 0; i < allTerms.length; i++) {\r\n    dotProduct += vectorA[i] * vectorB[i];\r\n  }\r\n  \r\n  // Calculate magnitudes\r\n  const magnitudeA = Math.sqrt(vectorA.reduce((sum, val) => sum + val * val, 0));\r\n  const magnitudeB = Math.sqrt(vectorB.reduce((sum, val) => sum + val * val, 0));\r\n  \r\n  // Handle edge case\r\n  if (magnitudeA === 0 || magnitudeB === 0) return 0;\r\n  \r\n  // Return cosine similarity\r\n  return dotProduct / (magnitudeA * magnitudeB);\r\n};\r\n\r\n// Calculate semantic similarity between two texts\r\nexport const calculateSimilarity = (textA, textB) => {\r\n  // Preprocess both texts\r\n  const tokensA = preprocessText(textA);\r\n  const tokensB = preprocessText(textB);\r\n  \r\n  if (tokensA.length === 0 || tokensB.length === 0) return 0;\r\n  \r\n  // Calculate cosine similarity\r\n  return cosineSimilarity(tokensA, tokensB);\r\n};\r\n\r\n// Find the best match in a set of documents for a query\r\nexport const findBestMatch = (query, documents, threshold = 0.2) => {\r\n  if (!query || !documents || documents.length === 0) return null;\r\n  \r\n  const processedQuery = preprocessText(query);\r\n  \r\n  // Calculate similarity scores for each document\r\n  const scores = documents.map(doc => ({\r\n    document: doc,\r\n    similarity: calculateSimilarity(processedQuery, doc.text || doc.keywords?.join(' ') || '')\r\n  }));\r\n  \r\n  // Sort by similarity score (descending)\r\n  scores.sort((a, b) => b.similarity - a.similarity);\r\n  \r\n  // Return the best match if it meets the threshold\r\n  return scores[0].similarity >= threshold ? scores[0].document : null;\r\n};\r\n\r\n// Extract entities from text (e.g., product names, numbers, dates)\r\nexport const extractEntities = (text) => {\r\n  const entities = {\r\n    products: [],\r\n    numbers: [],\r\n    dates: [],\r\n    locations: []\r\n  };\r\n  \r\n  if (!text) return entities;\r\n  \r\n  // Extract numbers (including those with units)\r\n  const numberPattern = /\\b\\d+(\\.\\d+)?\\s*(kg|g|mm|cm|m|inch|inches|yards|counts|ne)?\\b/gi;\r\n  const numberMatches = text.match(numberPattern) || [];\r\n  entities.numbers = numberMatches.map(match => match.trim());\r\n  \r\n  // Extract dates\r\n  const datePattern = /\\b(?:\\d{1,2}[-/]\\d{1,2}[-/]\\d{2,4}|\\d{1,2}(?:st|nd|rd|th)?\\s+(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*(?:\\s+\\d{2,4})?)\\b/gi;\r\n  entities.dates = text.match(datePattern) || [];\r\n  \r\n  // Extract common yarn types/products\r\n  const yarnTypes = ['cotton', 'polyester', 'blend', 'recycled', 'organic', 'vortex', 'ring spun', 'open end', 'oe yarn'];\r\n  yarnTypes.forEach(type => {\r\n    if (text.toLowerCase().includes(type)) {\r\n      entities.products.push(type);\r\n    }\r\n  });\r\n  \r\n  // Extract locations\r\n  const locations = ['india', 'karur', 'tamil nadu', 'sukkaliyur'];\r\n  locations.forEach(location => {\r\n    if (text.toLowerCase().includes(location)) {\r\n      entities.locations.push(location);\r\n    }\r\n  });\r\n  \r\n  return entities;\r\n};\r\n\r\n// Function to detect intent from user input\r\nexport const detectIntent = (text) => {\r\n  const lowerText = text.toLowerCase();\r\n  \r\n  // Common intent patterns\r\n  const intentPatterns = {\r\n    greeting: [\r\n      /^hi\\b|^hello\\b|^hey\\b|^greetings\\b|^good morning\\b|^good afternoon\\b|^good evening\\b/i,\r\n    ],\r\n    farewell: [\r\n      /^bye\\b|^goodbye\\b|^see you\\b|^farewell\\b|^have a good day\\b/i\r\n    ],\r\n    information: [\r\n      /what|how|which|where|when|why|who|tell me about|can you explain|i need to know|i want to know/i,\r\n      /about your company|about ksp yarns|company details|company information/i // Added pattern\r\n    ],\r\n    purchase: [\r\n      /buy|purchase|order|shop|get|acquire|cost|price|how much|how many/i\r\n    ],\r\n    complaint: [\r\n      /complaint|issue|problem|not happy|dissatisfied|poor|bad|terrible|awful|damaged|wrong/i\r\n    ],\r\n    gratitude: [\r\n      /thanks|thank you|appreciate|grateful|helpful/i\r\n    ],\r\n    cancellation: [\r\n      /cancel|refund|return|stop|don't want|changed my mind/i\r\n    ],\r\n    confirmation: [\r\n      /confirm|verify|check|sure|right|correct|ok|yes|yep|yeah/i\r\n    ],\r\n    negation: [\r\n      /no|nope|not|don't|none|never|negative/i\r\n    ]\r\n  };\r\n  \r\n  // Check for each intent\r\n  for (const [intent, patterns] of Object.entries(intentPatterns)) {\r\n    for (const pattern of patterns) {\r\n      if (pattern.test(lowerText)) {\r\n        return intent;\r\n      }\r\n    }\r\n  }\r\n  \r\n  return 'general';\r\n};\r\n\r\n// Generate contextual responses based on conversation history\r\nexport const generateContextualResponse = (query, matchedResponse, conversationContext) => {\r\n  // Removed unused intent variable\r\n  const entities = extractEntities(query);\r\n  \r\n  // If we have a specific response, customize it based on context\r\n  if (matchedResponse) {\r\n    // Add product specificity if detected\r\n    if (entities.products.length > 0 && matchedResponse.includes('products')) {\r\n      return matchedResponse.replace(\r\n        'our products', \r\n        `our ${entities.products.join(', ')} products`\r\n      );\r\n    }\r\n    \r\n    // Add personalization if we know the user name\r\n    if (conversationContext.userName && Math.random() > 0.7) {\r\n      if (matchedResponse.includes('.')) {\r\n        return matchedResponse.replace(\r\n          '. ', \r\n          `. ${conversationContext.userName}, `\r\n        );\r\n      }\r\n    }\r\n    \r\n    return matchedResponse;\r\n  }\r\n  \r\n  return null;\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}